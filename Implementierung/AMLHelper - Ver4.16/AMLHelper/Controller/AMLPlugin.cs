///////////////////////////////////////////////////////////
//  AMLHelper.cs
//  Implementation of the Class AMLHelper
//  Generated by Enterprise Architect
//  Created on:      30-Jan-2016 10:51:19
//  Original author: Dennis
///////////////////////////////////////////////////////////

using System.ComponentModel;
using System.ComponentModel.Composition;
using System.Threading;
using System.Windows;
using System.Windows.Input;
using System.Windows.Threading;
using AMLEditorPlugin.Base;
using AMLEditorPlugin.Contracts;
using AMLHelper.Model;
using AMLHelper.View;
using CAEX_ClassModel;

namespace AMLHelper.Controller
{
    /// <summary>
    /// Diese Klasse implementiert die AML Plugin Schnittstelle.
    /// Die Methode "ActivatePlugin" wird bei Start des Plugins aus dem AML Editor
    /// heraus aufgerufen.
    /// </summary>
    [Export(typeof(IAMLEditorPlugin))]
    public class AMLPlugin : PluginBase, INotifyPropertyChanged
    {
        private string _AMLFilePath;
        public string AMLFilePath
        {
            get
            {
                return _AMLFilePath;
            }            
            set 
            {
                _AMLFilePath = value;
                OnPropertyChanged("AMLFilePath");
            }
            
        }
        private Thread _mainWindowThread;
        private RelayCommand<object> _rCommand;
        public PluginWindow PluginWindow;
        
        public AMLPlugin()
        {
            Commands.Add(new PluginCommand
            {
                CommandName = "About",
                Command = AboutCommand
            });
            DisplayName = "AML Helper";
            
        }

        public ICommand ActivateCommand
        {
            get
            {
                return _rCommand
                   ??
                    (_rCommand = new RelayCommand<object>(ActivateCommandExecute, ActivateCommandCanExecute));
            }
        }

        public ICommand AboutCommand
        {
            get
            {
                return _rCommand
                   ??
                    (_rCommand = new RelayCommand<object>(AboutCommandExecute, AboutCommandCanExecute));
            }
        }

        public void Init()
        {

        }

        public override bool IsReactive
        {
            get { return false; }
        }

        public override bool IsReadonly
        {
            get { return false; }
        }

        /// <summary>
        /// Test, if the <see cref="AboutCommand"/> can execute.
        /// </summary>
        /// <param name="parameter">unused.</param>
        /// <returns>true, if command can execute</returns>
        private bool AboutCommandCanExecute(object parameter)
        {
            // Execution is always possible, also for inactive plugins
            return true;
        }

        /// 
        /// <param name="amlFilePath"></param>
        /// <param name="caex"></param>
        public override void PublishAutomationMLFileAndObject(string amlFilePath, CAEXBasicObject caex)
        {
            /*if (String.IsNullOrEmpty(amlFilePath))
            {
                CAEXDocument caex_doc = CAEXDocument.New_CAEXDocument();
                fi = FileInstance.getInstanceAndSetDoc(caex_doc);
                fi.ReloadCAEXDocument();
                String name = DateTime.Now.ToString("h:mm:ss tt");
                fi.AMLFilePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), name + ".aml");
                      
            }
            else
            {*/
                var fi = FileInstance.GetInstance();
                fi.AmlFilePath = amlFilePath;
                fi.ReloadCaexDocument();
            /*}*/

            PluginWindow.Dispatcher.Invoke(DispatcherPriority.Normal,
                new ThreadStart(() => { 
                    PluginWindow.CurrentFile = fi;
                    PluginWindow.Init();
                }));
        }


        /// <summary>
        /// Diese Methode wird ausgeführt wenn im AML Editor der Activate Eintrag im Submenu des Plugins angeklickt wird.
        /// Es wird dann ein neuer Thread für die GUI erstellt und das PluginWindow initialisiert.
        /// </summary>
        /// <param name="parameter"></param>
        protected override void ActivateCommandExecute(object parameter)
        {
            IsActive = true;

            var syncContext = SynchronizationContext.Current;
            if (syncContext != null)
            {
                _mainWindowThread = new Thread(() =>
                {
                    SynchronizationContext.SetSynchronizationContext(new DispatcherSynchronizationContext(Dispatcher.CurrentDispatcher));

                    PluginWindow = new PluginWindow(this);

                    #region Closing Event:
                    PluginWindow.Closed += (s, e) =>
                    {
                        IsActive = false;

                        // post the Terminated Event on the Synchronisation Context, so that the AMLEditor gets informed

                        // Shut Down the Dispatcher Thread
                        Dispatcher.CurrentDispatcher.BeginInvokeShutdown(DispatcherPriority.Background);
                    };
                    #endregion

                    PluginWindow.Show();
                    syncContext.Post(o => RaisePluginActivated(), this);
                    Dispatcher.Run();
                });
                // Set the apartment state
                _mainWindowThread.SetApartmentState(ApartmentState.STA);

                // Make the thread a background thread (not required)
                _mainWindowThread.IsBackground = true;

                // Start the thread
                _mainWindowThread.Start();
            }
            else
            {
                MessageBox.Show("Couldn't activate the Plugin UI Thread! No current Synchronisation Context exists!");
            }
        }

        protected void AboutCommandExecute(object parameter)
        {
            var about = new About();
            about.Show();
        }

        /// 
        /// <param name="prm1"></param>
        protected override void TerminateCommandExecute(object prm1)
        {
            PluginWindow.Dispatcher.Invoke(DispatcherPriority.Normal, new ThreadStart(PluginWindow.Close));
        }


        /// 
        /// <param name="prm1"></param>
        public override void ChangeAMLFilePath(string prm1)
        {

        }

        /// 
        /// <param name="prm1"></param>
        public override void ChangeSelectedObject(CAEXBasicObject prm1)
        {

        }


        #region INotifyPropertyChanged Member

        public event PropertyChangedEventHandler PropertyChanged;

        private void OnPropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }

        #endregion INotifyPropertyChanged Member
    }//end AMLHelper
    //while (AMLHelper.Controller.AMLHelper.AMLFilePath == null)
    //{

    //}
    //CAEXDocument doc = CAEXDocument.LoadFromFile(AMLHelper.Controller.AMLHelper.AMLFilePath);
    //foreach (InstanceHierarchyType ih in doc.CAEXFile.InstanceHierarchy) {
    //    tree.BuildTreeFor(ih);
    //}
}//end namespace Controller